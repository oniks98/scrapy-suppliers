# Изменения в Scrapy Pipeline и Spider

## Дата изменений: 23.11.2025

---

## 1. Последовательная нумерация товаров (200000, 200001, 200002...)

### Проблема
При фильтрации товаров коды шли непоследовательно:
- 200000
- 200002
- 200007

### Решение
Перенесена генерация кодов из spider в pipeline. Теперь коды присваиваются **только** прошедшим фильтрацию товарам.

**Файл:** `pipelines.py`

```python
# Добавлены счетчики в __init__
self.retail_product_counter = 200000
self.dealer_product_counter = 200000

# В process_item код присваивается ПОСЛЕ фильтрации
if price_type == "dealer":
    cleaned_item["Код_товару"] = str(self.dealer_product_counter)
    self.dealer_product_counter += 1
else:
    cleaned_item["Код_товару"] = str(self.retail_product_counter)
    self.retail_product_counter += 1
```

**Файл:** `viatec_retail.py`

```python
# Удален метод _generate_product_code
# В parse_product_ru:
code = ""  # Pipeline присвоит код автоматически
```

---

## 2. Производитель (Виробник) записывается корректно

### Проблема
В некоторых товарах поле "Виробник" было пустым, хотя в названии товара был указан производитель.

Пример:
- Код 200000: "**PTZ видеокамера Hikvision DS-2DE1C200IW**" - Виробник пустой
- Код 200007: "**IP видеокамера Dahua DH-H5B**" - Виробник: Dahua Technology

### Причина
Метод `_extract_manufacturer_from_url` искал производителя в **URL товара**, но на сайте viatec.ua URL товаров не содержат информацию о производителе.

### Решение
Создан новый метод `_extract_manufacturer`, который ищет производителя в **названии товара**.

**Файл:** `viatec_retail.py`

```python
def _extract_manufacturer(self, product_name):
    """Определяет производителя из названия товара"""
    if not product_name:
        return ""
    
    product_name_lower = product_name.lower()
    
    # Кэш производителей для избежания повторного парсинга CSV
    if not hasattr(self, "_manufacturers_cache"):
        self._manufacturers_cache = self._load_manufacturers_from_csv()
    
    # Ищем производителя в CSV по совпадению с названием товара
    for keyword, manufacturer in self._manufacturers_cache.items():
        if keyword.lower() in product_name_lower:
            return manufacturer
    
    # Встроенный маппинг как запасной вариант
    name_patterns = {
        "hikvision": "Hikvision",
        "dahua": "Dahua Technology",
        "ds-": "Hikvision",  # Модели Hikvision начинаются с DS-
        "dh-": "Dahua Technology",  # Модели Dahua начинаются с DH-
        "dhi-": "Dahua Technology",
    }
    
    for pattern, name in name_patterns.items():
        if pattern in product_name_lower:
            return name
    
    return ""
```

**Как работает:**

1. **Первый приоритет**: Поиск в CSV файле `manufacturers_viatec.csv`
   - Например, если в названии есть "**Hikvision**", то вернется "Hikvision"
   - Если в названии есть "**DS**" (из CSV), то вернется "Hikvision"

2. **Второй приоритет**: Встроенные паттерны
   - Если в названии есть "**ds-**" (нижний регистр), то вернется "Hikvision"
   - Если в названии есть "**dh-**" или "**dhi-**", то вернется "Dahua Technology"

**Примеры:**

| Название товара | Производитель |
|---|---|
| PTZ видеокамера **Hikvision** DS-2DE1C200IW | Hikvision |
| IP видеокамера **Dahua** DH-IPC-HFW2849 | Dahua Technology |
| IP видеокамера **Imou** IPC-L26P | Imou |
| HDCVI видеокамера **DS**-2CE16D3T | Hikvision |
| IP видеокамера **DH**-IPC-PTS2649C | Dahua Technology |
| HDTVI видеокамера Hikvision **DS**-2CE5AU7T | Hikvision |

**Важно:** Теперь производитель определяется из **названия товара**, а не из URL, что гарантирует корректное заполнение поля "Виробник" для всех товаров.

---

## 3. Удаление текста "Є товари з аналогічними характеристиками →" из описания

### Проблема
В столбик "Опис товару" попадал ненужный текст:
```html
<p class="card-header__analog-link">Є товари з аналогічними характеристиками → </p>
```

### Решение

**Файл:** `viatec_retail.py`

Создан новый метод `_extract_description_with_br`:

```python
def _extract_description_with_br(self, response):
    """Извлечение описания с сохранением переносов <br>"""
    description_html = response.css("div.card-header__card-info-text").get()
    
    if not description_html:
        return ""
    
    from scrapy import Selector
    desc_selector = Selector(text=description_html)
    paragraphs = desc_selector.css("p")
    
    result_parts = []
    for p in paragraphs:
        # Пропускаем параграф с классом card-header__analog-link
        if p.css("::attr(class)").get() == "card-header__analog-link":
            continue
        
        # Получаем HTML и заменяем <br> на \n
        p_html = p.get()
        p_html = p_html.replace("<br>", "\n").replace("<br/>", "\n").replace("<br />", "\n")
        
        text_selector = Selector(text=p_html)
        text = "".join(text_selector.css("::text").getall()).strip()
        
        if text:
            result_parts.append(text)
    
    return "\n".join(result_parts)
```

**Файл:** `pipelines.py`

Дополнительно добавлен метод для очистки текста про аналоги на уровне pipeline:

```python
def _clean_description(self, description):
    """Очищает описание от текста про аналоги"""
    if not description:
        return ""
    
    patterns_to_remove = [
        r"Є товари з аналогічними характеристиками\s*→",
        r"Есть товары с аналогичными характеристиками\s*→",
    ]
    
    for pattern in patterns_to_remove:
        description = re.sub(pattern, "", description, flags=re.IGNORECASE)
    
    description = re.sub(r'\s+', ' ', description)
    return description.strip()
```

---

## 4. Сохранение переносов строк из `<br>` в описании

### Проблема
На сайте поставщика описание содержит `<br>`, но в CSV файле текст шел сплошным:

```
● Роздільна здатність 2МП● Фокус 2.8мм● Максимальна роздільна здатність
```

### Решение
В методе `_extract_description_with_br` переносы `<br>` заменяются на символ новой строки `\n`:

```python
p_html = p_html.replace("<br>", "\n").replace("<br/>", "\n").replace("<br />", "\n")
```

Теперь в CSV файле описание выглядит так:

```
● Роздільна здатність 2МП
● Фокус 2.8мм
● Максимальна роздільна здатність
```

---

## 5. Увеличено количество характеристик с 50 до 60

**Файл:** `pipelines.py`

```python
# Было:
for i in range(1, 51):
    self.fieldnames.extend([...])

# Стало:
for i in range(1, 61):
    self.fieldnames.extend([...])
```

**Файл:** `viatec_retail.py`

```python
# Было:
for i, row in enumerate(spec_rows[:50], 1):

# Стало:
for i, row in enumerate(spec_rows[:60], 1):
```

---

## 6. Извлечение количества товара из статуса наличия

### Проблема
Если селектор показывает:
```html
<div class="card-header__card-status-badge">В наявності 9 шт</div>
```

То цифра "9" должна записаться в столбик "Кількість", а в "Наявність" должен быть "+".

### Решение

**Файл:** `pipelines.py`

```python
def _extract_quantity(self, availability_str):
    """
    Извлекает количество из строки вида "В наличии 5 шт"
    Возвращает только цифру
    """
    if not availability_str:
        return ""
    
    # Ищем число в строке
    match = re.search(r'\d+', str(availability_str))
    
    if match:
        return match.group()
    
    return ""
```

Метод вызывается в `process_item`:

```python
# Извлекаем количество из строки "В наличии 5 шт"
quantity = self._extract_quantity(availability_raw)

# Обновляем поля наличия
cleaned_item["Наявність"] = "+"  # Всегда "+" если товар прошёл фильтр
cleaned_item["Кількість"] = quantity if quantity else ""
```

---

## Итоговые изменения

### pipelines.py
1. ✅ Добавлены счетчики `retail_product_counter` и `dealer_product_counter`
2. ✅ Код товара генерируется ПОСЛЕ фильтрации
3. ✅ Увеличено количество характеристик с 50 до 60
4. ✅ Добавлен метод `_clean_description` для удаления текста про аналоги
5. ✅ Добавлен метод `_extract_quantity` для извлечения количества

### viatec_retail.py
1. ✅ Удален метод `_generate_product_code`
2. ✅ Добавлен метод `_extract_description_with_br` для корректного извлечения описания
3. ✅ Увеличено количество характеристик с 50 до 60
4. ✅ Код товара теперь пустая строка (присваивается в pipeline)
5. ✅ Добавлен новый метод `_extract_manufacturer` для определения производителя из названия товара
6. ✅ Метод `_extract_manufacturer_from_url` помечен как DEPRECATED

---

## Запуск Spider

```bash
cd C:\FullStack\Scrapy\suppliers
scrapy crawl viatec_retail
```

## Проверка результатов

Файл создается по пути:
```
C:\FullStack\Scrapy\output\prom_import.csv
```

Проверьте:
- ✅ Коды товаров идут последовательно: 200000, 200001, 200002...
- ✅ **Производитель заполнен во всех товарах (определяется из названия)**
- ✅ Описание без текста про аналоги
- ✅ Описание содержит переносы строк
- ✅ Столбик "Кількість" заполнен цифрой, если была в статусе наличия
- ✅ Столбик "Наявність" всегда "+"
